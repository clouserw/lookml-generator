window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "generator", "modulename": "generator", "type": "module", "doc": "<p>Generate LookML.</p>\n\n<h1 id=\"lookml-generator\">lookml-generator</h1>\n\n<p><a href=\"https://circleci.com/gh/mozilla/lookml-generator/?branch=main\"><img src=\"https://circleci.com/gh/mozilla/lookml-generator.svg?style=svg\" alt=\"mozilla\" /></a></p>\n\n<p><em>Under Active Development</em></p>\n\n<p>LookML Generator for Glean and Mozilla Data.</p>\n\n<p>The lookml-generator has two important roles:</p>\n\n<ol>\n<li>Generate a listing of all Glean/Mozilla namespaces and their associated BigQuery tables</li>\n<li>From that listing, generate LookML for views, explores, and dashboards and push those to the <a href=\"https://github.com/mozilla/looker-hub\">Look Hub project</a></li>\n</ol>\n\n<h2 id=\"generating-namespace-listings\">Generating Namespace Listings</h2>\n\n<p>At Mozilla, a namespace is a single functional area that is represented in Looker with (usually) one model*.\nEach Glean application is self-contained within a single namespace, containing the data from <a href=\"https://probeinfo.telemetry.mozilla.org/v2/glean/app-listings\">across that application's channels</a>.\nWe also support custom namespaces, which can use wildcards to denote their BigQuery datasets and tables. These are described in <code>custom-namespaces.yaml</code>.</p>\n\n<p><img src=\"https://github.com/mozilla/lookml-generator/blob/main/architecture/namespaces.jpg?raw=true\" alt=\"alt text\" /></p>\n\n<blockquote>\n  <p>*  Though namespaces are not limited to a single model, we advise it for clarity's sake.</p>\n</blockquote>\n\n<h2 id=\"adding-custom-namespaces\">Adding Custom Namespaces</h2>\n\n<p>Custom namespaces need to be defined explicitly in <code>custom-namespaces.yaml</code>. For each namespace views and explores to be generated need to be specified.</p>\n\n<p>Make sure the custom namespaces is _not_ listed in <code>namespaces-disallowlist.yaml</code>.</p>\n\n<p>Once changes have been approved and merged, the <a href=\"#deploying-new-lookml-generator-changes\">lookml-generator changes can get deployed</a>.</p>\n\n<h2 id=\"generating-lookml\">Generating LookML</h2>\n\n<p>Once we know which tables are associated with which namespaces, we can generate LookML files and update our Looker instance.</p>\n\n<p>Lookml-generator generates LookML based on both the BigQuery schema and manual changes. For example, we would want to add <code>city</code> drill-downs for all <code>country</code> fields.\n<img src=\"https://github.com/mozilla/lookml-generator/blob/main/architecture/lookml.jpg?raw=true\" alt=\"alt text\" /></p>\n\n<h3 id=\"pushing-changes-to-dev-branches\">Pushing Changes to Dev Branches</h3>\n\n<p>In addition to pushing new lookml to the <a href=\"https://github.com/mozilla/looker-hub\">main branch</a>, we reset the dev branches to also\npoint to the commit at <code>main</code>. This only happens during production deployment runs.</p>\n\n<p>To automate this process for your dev branch, add it to <a href=\"https://github.com/mozilla/lookml-generator/tree/main/bin/dev_branches\">this file</a>.\nYou can edit that file in your browser. Open a PR and tag <a href=\"https://github.com/orgs/mozilla/teams/data-looker\">data-looker</a> for review.\nYou can find your dev branch by going to <a href=\"https://mozilla.cloud.looker.com\">Looker</a>, entering development mode, opening the <a href=\"https://mozilla.cloud.looker.com/projects/looker-hub\"><code>looker-hub</code></a>\nproject, clicking the \"Git Actions\" icon, and finding your personal branch in the \"Current Branch\" dropdown.</p>\n\n<h2 id=\"setup\">Setup</h2>\n\n<p>Ensure Python 3.8+ is available on your machine (see <a href=\"https://docs.python-guide.org/starting/install3/osx/\">this guide</a> for instructions if you're on a mac and haven't installed anything other than the default system Python.)</p>\n\n<p>You will also need the Google Cloud SDK with valid credentials.\nAfter setting up the Google Cloud SDK, run:</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code>gcloud config <span class=\"nb\">set</span> project moz-fx-data-shared-prod\ngcloud auth login --update-adc\n</code></pre></div>\n\n<p>Install requirements in a Python venv</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code>python3.8 -m venv venv/\nvenv/bin/pip install --no-deps -r requirements.txt\n</code></pre></div>\n\n<p>Update requirements when they change with <code>pip-sync</code></p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code>venv/bin/pip-sync\n</code></pre></div>\n\n<p>Setup pre-commit hooks</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code>venv/bin/pre-commit install\n</code></pre></div>\n\n<p>Run unit tests and linters</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code>venv/bin/pytest\n</code></pre></div>\n\n<p>Run integration tests</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code>venv/bin/pytest -m integration\n</code></pre></div>\n\n<p>Note that the integration tests require a valid login to BigQuery to succeed.</p>\n\n<h2 id=\"testing-generation-locally\">Testing generation locally</h2>\n\n<p>You can test namespace generation by running:</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code>./bin/generator namespaces\n</code></pre></div>\n\n<p>To generate the actual lookml (in <code>looker-hub</code>), run:</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code>./bin/generator lookml\n</code></pre></div>\n\n<h2 id=\"container-development\">Container Development</h2>\n\n<p>Most code changes will not require changes to the generation script or container.\nHowever, you can test it locally. The following script will test generation, pushing\na new branch to the <code>looker-hub</code> repository:</p>\n\n<pre><code>export HUB_BRANCH_PUBLISH=\"yourname-generation-test-1\"\nexport GIT_SSH_KEY_BASE64=$(cat ~/.ssh/id_rsa | base64)\nmake build &amp;&amp; make run\n</code></pre>\n\n<h2 id=\"deploying-new-lookml-generator-changes\">Deploying new <code>lookml-generator</code> changes</h2>\n\n<p><code>lookml-generator</code> runs daily to update the <code>looker-hub</code> and <code>looker-spoke-default</code> code. Changes\nto the underlying tables should automatically propogate to their respective views and explores.</p>\n\n<p>However, changes to <code>lookml-generator</code> need to be tested on stage and deployed. The general process\nis the following:</p>\n\n<ol>\n<li>Create a PR, test on dev. It is not necessary to add Looker credentials, but the container changes\nshould run using <code>make build &amp;&amp; make run</code>, with changes reflected in LookML repos.</li>\n<li>Once merged, the changes should run on stage. They will run automatically after schema deploys,\nbut they can be run manually by clearing the <code>lookml_generator_staging</code> task in <a href=\"https://workflow.telemetry.mozilla.org/tree?dag_id=probe_scraper\">Airflow</a>.</li>\n<li>Once the changes are confirmed in stage, we first tag a new release here. Add a description with\nwhat the new release includes. Finally, change the Airflow variable <code>lookml_generator_release_str</code>\nto the version string you created when cutting the release. Re-run the DAG and the changes\nshould take effect.</li>\n</ol>\n\n<h1 id=\"namespacesyaml\"><code>namespaces.yaml</code></h1>\n\n<p>We use <a href=\"https://github.com/mozilla/looker-hub/blob/main/namespaces.yaml\"><code>namespaces.yaml</code></a> as the declarative listing of the Looker namespaces generated by this repository.</p>\n\n<p>Each entry in <code>namespaces.yaml</code> represents a namespace, and has the following properties:</p>\n\n<ul>\n<li><code>owners</code> (string): The owners are the people who will have control over the associated Namespace folder in Looker. It is up to them to decide which dashboards to \"promote\" to their shared folder.</li>\n<li><code>pretty_name</code> (string): The pretty name is used in most places where the namespace's name is seen, e.g. in the explore drop-down and folder name.</li>\n<li><code>glean_app</code> (bool): Whether or not this namespace represents a Glean Application.</li>\n<li><code>connection</code> (optional string): The database connection to use, as named in Looker. Defaults to <code>telemetry</code>.</li>\n<li><code>views</code> (object): The LookML View files that will be generated. More detailed info below.</li>\n<li><code>explores</code> (object): The LookML Explore files that will be generated. More detailed info below.</li>\n</ul>\n\n<h2 id=\"views\"><code>views</code></h2>\n\n<p>Each View entry is actually a LookML view file that will be generated.\nEach LookML View file can contain multiple Looker Views; the idea here is that these views are related and used together. By convention, the first view in the file is the base view (i.e. associated join views folllow after the explore containing the base dimension and metrics).</p>\n\n<ul>\n<li><code>type</code>: The type of the view, e.g. <code>glean_ping_view</code>.</li>\n<li><code>tables</code>: This field is used in a few ways, depending on the associated View type.</li>\n</ul>\n\n<p>For <code>GleanPingView</code> and <code>PingView</code>, <code>tables</code> represents all of the associated channels for that view. Each table will have a <code>channel</code> and <code>table</code> entry. Only a single view will be created in the LookML File.</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"nt\">tables</span><span class=\"p\">:</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p p-Indicator\">-</span><span class=\"w\"> </span><span class=\"nt\">channel</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"l l-Scalar l-Scalar-Plain\">release</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nt\">table</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"l l-Scalar l-Scalar-Plain\">mozdata.org_mozilla_firefox.metrics</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p p-Indicator\">-</span><span class=\"w\"> </span><span class=\"nt\">channel</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"l l-Scalar l-Scalar-Plain\">nightly</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nt\">table</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"l l-Scalar l-Scalar-Plain\">mozdata.org_mozilla_fenix.metrics</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>For <code>ClientCountView</code> and <code>GrowthAccountingView</code>, <code>tables</code> will have a single entry, with the name of the table the Looker View is based off of. Only a single Looker View will be created.</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"nt\">tables</span><span class=\"p\">:</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p p-Indicator\">-</span><span class=\"w\"> </span><span class=\"nt\">table</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"l l-Scalar l-Scalar-Plain\">mozdata.org_mozilla_firefox.baseline_clients_last_seen</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>For <code>FunnelAnalysisView</code>, only the first list entry is used; inside that entry, each value represents a Looker View that is created. The key is the name of the view, the value is the Looker View or BQ View it is derived from.\nIn the following example, 4 views will be created in the view file: <code>funnel_analysis</code>, <code>event_types</code>, <code>event_type_1</code> and <code>event_type_2</code>.</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"nt\">tables</span><span class=\"p\">:</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p p-Indicator\">-</span><span class=\"w\"> </span><span class=\"nt\">funnel_analysis</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"l l-Scalar l-Scalar-Plain\">events_daily_table</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nt\">event_types</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"l l-Scalar l-Scalar-Plain\">mozdata.glean_app.event_types`</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nt\">event_type_1</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"l l-Scalar l-Scalar-Plain\">event_types</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nt\">event_type_2</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"l l-Scalar l-Scalar-Plain\">event_types</span><span class=\"w\"></span>\n</code></pre></div>\n\n<h2 id=\"explores\"><code>explores</code></h2>\n\n<p>Each Explore entry is a single file, sometimes containing multiple explores within it (mainly for things like changing suggestions).</p>\n\n<ul>\n<li><code>type</code> - The type of the explore, e.g. <code>growth_accounting_explore</code>.</li>\n<li><code>views</code> - The views that this is based on. Generally, the allowed keys here are:\n<ul>\n<li><code>base_view</code>: The base view is the one we are basing this Explore on, using <a href=\"https://docs.looker.com/reference/explore-params/view_name\"><code>view_name</code></a>.</li>\n<li><code>extended_view*</code>: Any views we include in the <code>base_view</code> are added as these. It could be one (<code>extended_view</code>) or multiple (<code>extended_view_1</code>).</li>\n<li><code>joined_view*</code>: Any other view we are going to join to this one. _This is only required if the joined view is not defined in the same view file as <code>base_view</code>._</li>\n</ul></li>\n</ul>\n\n<p>It may not necessarily be desirable to list all of the views and explores in the <code>namespace.yaml</code> (e.g. suggest explores specific to a view). In these cases, it is useful to adopt the convention where the first view is the primary view for the explore.</p>\n"}, {"fullname": "generator.cli", "modulename": "generator", "qualname": "cli", "type": "function", "doc": "<p>Generate and run CLI.</p>\n", "signature": "(prog_name=None)", "funcdef": "def"}, {"fullname": "generator.dashboards", "modulename": "generator.dashboards", "type": "module", "doc": "<p>All possible dashboard types.</p>\n"}, {"fullname": "generator.dashboards.dashboard", "modulename": "generator.dashboards.dashboard", "type": "module", "doc": "<p>Generic dashboard type.</p>\n"}, {"fullname": "generator.dashboards.dashboard.Dashboard", "modulename": "generator.dashboards.dashboard", "qualname": "Dashboard", "type": "class", "doc": "<p>A generic Looker Dashboard.</p>\n"}, {"fullname": "generator.dashboards.dashboard.Dashboard.__init__", "modulename": "generator.dashboards.dashboard", "qualname": "Dashboard.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    title: str,\n    name: str,\n    layout: str,\n    namespace: str,\n    tables: List[Dict[str, str]]\n)", "funcdef": "def"}, {"fullname": "generator.dashboards.dashboard.Dashboard.to_dict", "modulename": "generator.dashboards.dashboard", "qualname": "Dashboard.to_dict", "type": "function", "doc": "<p>Dashboard instance represented as a dict.</p>\n", "signature": "(self) -> dict", "funcdef": "def"}, {"fullname": "generator.dashboards.dashboard.Dashboard.to_lookml", "modulename": "generator.dashboards.dashboard", "qualname": "Dashboard.to_lookml", "type": "function", "doc": "<p>Generate Lookml for this dashboard.</p>\n", "signature": "(self, client)", "funcdef": "def"}, {"fullname": "generator.dashboards.operational_monitoring_dashboard", "modulename": "generator.dashboards.operational_monitoring_dashboard", "type": "module", "doc": "<p>Class to describe Operational Monitoring Dashboard.</p>\n"}, {"fullname": "generator.dashboards.operational_monitoring_dashboard.OperationalMonitoringDashboard", "modulename": "generator.dashboards.operational_monitoring_dashboard", "qualname": "OperationalMonitoringDashboard", "type": "class", "doc": "<p>An Operational Monitoring dashboard.</p>\n", "bases": "generator.dashboards.dashboard.Dashboard"}, {"fullname": "generator.dashboards.operational_monitoring_dashboard.OperationalMonitoringDashboard.__init__", "modulename": "generator.dashboards.operational_monitoring_dashboard", "qualname": "OperationalMonitoringDashboard.__init__", "type": "function", "doc": "<p>Get an instance of a Operational Monitoring Dashboard.</p>\n", "signature": "(\n    self,\n    title: str,\n    name: str,\n    layout: str,\n    namespace: str,\n    defn: List[Dict[str, Any]]\n)", "funcdef": "def"}, {"fullname": "generator.dashboards.operational_monitoring_dashboard.OperationalMonitoringDashboard.type", "modulename": "generator.dashboards.operational_monitoring_dashboard", "qualname": "OperationalMonitoringDashboard.type", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'operational_monitoring_dashboard'"}, {"fullname": "generator.dashboards.operational_monitoring_dashboard.OperationalMonitoringDashboard.OPMON_DASH_EXCLUDED_FIELDS", "modulename": "generator.dashboards.operational_monitoring_dashboard", "qualname": "OperationalMonitoringDashboard.OPMON_DASH_EXCLUDED_FIELDS", "type": "variable", "doc": "<p></p>\n", "annotation": ": List[str]", "default_value": " = ['branch', 'probe', 'histogram__VALUES__key', 'histogram__VALUES__value']"}, {"fullname": "generator.dashboards.operational_monitoring_dashboard.OperationalMonitoringDashboard.from_dict", "modulename": "generator.dashboards.operational_monitoring_dashboard", "qualname": "OperationalMonitoringDashboard.from_dict", "type": "function", "doc": "<p>Get a OperationalMonitoringDashboard from a dict representation.</p>\n", "signature": "(\n    klass,\n    namespace: str,\n    name: str,\n    defn: dict\n) -> generator.dashboards.operational_monitoring_dashboard.OperationalMonitoringDashboard", "funcdef": "def"}, {"fullname": "generator.dashboards.operational_monitoring_dashboard.OperationalMonitoringDashboard.to_lookml", "modulename": "generator.dashboards.operational_monitoring_dashboard", "qualname": "OperationalMonitoringDashboard.to_lookml", "type": "function", "doc": "<p>Get this dashboard as LookML.</p>\n", "signature": "(self, bq_client)", "funcdef": "def"}, {"fullname": "generator.explores", "modulename": "generator.explores", "type": "module", "doc": "<p>All possible explore types.</p>\n"}, {"fullname": "generator.explores.client_counts_explore", "modulename": "generator.explores.client_counts_explore", "type": "module", "doc": "<p>Client Counts explore type.</p>\n"}, {"fullname": "generator.explores.client_counts_explore.ClientCountsExplore", "modulename": "generator.explores.client_counts_explore", "qualname": "ClientCountsExplore", "type": "class", "doc": "<p>A Client Counts Explore, from Baseline Clients Last Seen.</p>\n", "bases": "generator.explores.explore.Explore"}, {"fullname": "generator.explores.client_counts_explore.ClientCountsExplore.type", "modulename": "generator.explores.client_counts_explore", "qualname": "ClientCountsExplore.type", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'client_counts_explore'"}, {"fullname": "generator.explores.client_counts_explore.ClientCountsExplore.queries", "modulename": "generator.explores.client_counts_explore", "qualname": "ClientCountsExplore.queries", "type": "variable", "doc": "<p></p>\n", "annotation": ": List[dict]", "default_value": " = [{'description': 'Client Counts of weekly cohorts over the past N days.', 'dimensions': ['days_since_first_seen', 'first_seen_week'], 'measures': ['client_count'], 'pivots': ['first_seen_week'], 'filters': [{'submission_date': '8 weeks'}, {'first_seen_date': '8 weeks'}, {'have_completed_period': 'yes'}], 'sorts': [{'days_since_first_seen': 'asc'}], 'name': 'cohort_analysis'}, {'description': 'Number of clients per build.', 'dimensions': ['submission_date', 'app_build'], 'measures': ['client_count'], 'pivots': ['app_build'], 'sorts': [{'submission_date': 'asc'}], 'name': 'build_breakdown'}]"}, {"fullname": "generator.explores.client_counts_explore.ClientCountsExplore.from_views", "modulename": "generator.explores.client_counts_explore", "qualname": "ClientCountsExplore.from_views", "type": "function", "doc": "<p>If possible, generate a Client Counts explore for this namespace.</p>\n\n<p>Client counts explores are only created for client_counts views.</p>\n", "signature": "(\n    views: List[generator.views.view.View]\n) -> Iterator[generator.explores.client_counts_explore.ClientCountsExplore]", "funcdef": "def"}, {"fullname": "generator.explores.client_counts_explore.ClientCountsExplore.from_dict", "modulename": "generator.explores.client_counts_explore", "qualname": "ClientCountsExplore.from_dict", "type": "function", "doc": "<p>Get an instance of this explore from a dictionary definition.</p>\n", "signature": "(\n    name: str,\n    defn: dict,\n    views_path: pathlib.Path\n) -> generator.explores.client_counts_explore.ClientCountsExplore", "funcdef": "def"}, {"fullname": "generator.explores.events_explore", "modulename": "generator.explores.events_explore", "type": "module", "doc": "<p>An explore for Events Views.</p>\n"}, {"fullname": "generator.explores.events_explore.EventsExplore", "modulename": "generator.explores.events_explore", "qualname": "EventsExplore", "type": "class", "doc": "<p>An Events Explore, from any unnested events table.</p>\n", "bases": "generator.explores.explore.Explore"}, {"fullname": "generator.explores.events_explore.EventsExplore.type", "modulename": "generator.explores.events_explore", "qualname": "EventsExplore.type", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'events_explore'"}, {"fullname": "generator.explores.events_explore.EventsExplore.queries", "modulename": "generator.explores.events_explore", "qualname": "EventsExplore.queries", "type": "variable", "doc": "<p></p>\n", "annotation": ": List[dict]", "default_value": " = [{'description': 'Event counts from all events over the past two weeks.', 'dimensions': ['submission_date'], 'measures': ['event_count'], 'filters': [{'submission_date': '14 days'}], 'name': 'all_event_counts'}]"}, {"fullname": "generator.explores.events_explore.EventsExplore.from_views", "modulename": "generator.explores.events_explore", "qualname": "EventsExplore.from_views", "type": "function", "doc": "<p>Where possible, generate EventsExplores for Views.</p>\n", "signature": "(\n    views: List[generator.views.view.View]\n) -> Iterator[generator.explores.events_explore.EventsExplore]", "funcdef": "def"}, {"fullname": "generator.explores.events_explore.EventsExplore.from_dict", "modulename": "generator.explores.events_explore", "qualname": "EventsExplore.from_dict", "type": "function", "doc": "<p>Get an instance of this explore from a dictionary definition.</p>\n", "signature": "(\n    name: str,\n    defn: dict,\n    views_path: pathlib.Path\n) -> generator.explores.events_explore.EventsExplore", "funcdef": "def"}, {"fullname": "generator.explores.explore", "modulename": "generator.explores.explore", "type": "module", "doc": "<p>Generic explore type.</p>\n"}, {"fullname": "generator.explores.explore.Explore", "modulename": "generator.explores.explore", "qualname": "Explore", "type": "class", "doc": "<p>A generic explore.</p>\n"}, {"fullname": "generator.explores.explore.Explore.__init__", "modulename": "generator.explores.explore", "qualname": "Explore.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    name: str,\n    views: Dict[str, str],\n    views_path: Union[pathlib.Path, NoneType] = None,\n    defn: Union[Dict[str, str], NoneType] = None\n)", "funcdef": "def"}, {"fullname": "generator.explores.explore.Explore.views_path", "modulename": "generator.explores.explore", "qualname": "Explore.views_path", "type": "variable", "doc": "<p></p>\n", "annotation": ": Union[pathlib.Path, NoneType]", "default_value": " = None"}, {"fullname": "generator.explores.explore.Explore.defn", "modulename": "generator.explores.explore", "qualname": "Explore.defn", "type": "variable", "doc": "<p></p>\n", "annotation": ": Union[Dict[str, str], NoneType]", "default_value": " = None"}, {"fullname": "generator.explores.explore.Explore.to_dict", "modulename": "generator.explores.explore", "qualname": "Explore.to_dict", "type": "function", "doc": "<p>Explore instance represented as a dict.</p>\n", "signature": "(self) -> dict", "funcdef": "def"}, {"fullname": "generator.explores.explore.Explore.to_lookml", "modulename": "generator.explores.explore", "qualname": "Explore.to_lookml", "type": "function", "doc": "<p>Generate LookML for this explore.</p>\n\n<p>Any generation done in dependent explore's\n<code>_to_lookml</code> takes precedence over these fields.</p>\n", "signature": "(\n    self,\n    client: google.cloud.bigquery.client.Client,\n    v1_name: Union[str, NoneType]\n) -> List[Dict[str, Any]]", "funcdef": "def"}, {"fullname": "generator.explores.explore.Explore.get_dependent_views", "modulename": "generator.explores.explore", "qualname": "Explore.get_dependent_views", "type": "function", "doc": "<p>Get views this explore is dependent on.</p>\n", "signature": "(self) -> List[str]", "funcdef": "def"}, {"fullname": "generator.explores.explore.Explore.from_dict", "modulename": "generator.explores.explore", "qualname": "Explore.from_dict", "type": "function", "doc": "<p>Get an instance of an explore from a namespace definition.</p>\n", "signature": "(\n    name: str,\n    defn: dict,\n    views_path: pathlib.Path\n) -> generator.explores.explore.Explore", "funcdef": "def"}, {"fullname": "generator.explores.explore.Explore.get_view_lookml", "modulename": "generator.explores.explore", "qualname": "Explore.get_view_lookml", "type": "function", "doc": "<p>Get the LookML for a view.</p>\n", "signature": "(self, view: str) -> dict", "funcdef": "def"}, {"fullname": "generator.explores.explore.Explore.get_unnested_fields_joins_lookml", "modulename": "generator.explores.explore", "qualname": "Explore.get_unnested_fields_joins_lookml", "type": "function", "doc": "<p>Get the LookML for joining unnested fields.</p>\n", "signature": "(self) -> list", "funcdef": "def"}, {"fullname": "generator.explores.explore.Explore.get_required_filters", "modulename": "generator.explores.explore", "qualname": "Explore.get_required_filters", "type": "function", "doc": "<p>Get required filters for this view.</p>\n", "signature": "(self, view_name: str) -> List[Dict[str, str]]", "funcdef": "def"}, {"fullname": "generator.explores.funnel_analysis_explore", "modulename": "generator.explores.funnel_analysis_explore", "type": "module", "doc": "<p>Funnel Analysis explore type.</p>\n"}, {"fullname": "generator.explores.funnel_analysis_explore.FunnelAnalysisExplore", "modulename": "generator.explores.funnel_analysis_explore", "qualname": "FunnelAnalysisExplore", "type": "class", "doc": "<p>A Funnel Analysis Explore, from Baseline Clients Last Seen.</p>\n", "bases": "generator.explores.explore.Explore"}, {"fullname": "generator.explores.funnel_analysis_explore.FunnelAnalysisExplore.type", "modulename": "generator.explores.funnel_analysis_explore", "qualname": "FunnelAnalysisExplore.type", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'funnel_analysis_explore'"}, {"fullname": "generator.explores.funnel_analysis_explore.FunnelAnalysisExplore.n_funnel_steps", "modulename": "generator.explores.funnel_analysis_explore", "qualname": "FunnelAnalysisExplore.n_funnel_steps", "type": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": " = 4"}, {"fullname": "generator.explores.funnel_analysis_explore.FunnelAnalysisExplore.from_views", "modulename": "generator.explores.funnel_analysis_explore", "qualname": "FunnelAnalysisExplore.from_views", "type": "function", "doc": "<p>If possible, generate a Funnel Analysis explore for this namespace.</p>\n\n<p>Funnel analysis explores are only created for funnel_analysis views.</p>\n", "signature": "(\n    views: List[generator.views.view.View]\n) -> Iterator[generator.explores.funnel_analysis_explore.FunnelAnalysisExplore]", "funcdef": "def"}, {"fullname": "generator.explores.funnel_analysis_explore.FunnelAnalysisExplore.from_dict", "modulename": "generator.explores.funnel_analysis_explore", "qualname": "FunnelAnalysisExplore.from_dict", "type": "function", "doc": "<p>Get an instance of this explore from a dictionary definition.</p>\n", "signature": "(\n    name: str,\n    defn: dict,\n    views_path: pathlib.Path\n) -> generator.explores.funnel_analysis_explore.FunnelAnalysisExplore", "funcdef": "def"}, {"fullname": "generator.explores.glean_ping_explore", "modulename": "generator.explores.glean_ping_explore", "type": "module", "doc": "<p>Glean Ping explore type.</p>\n"}, {"fullname": "generator.explores.glean_ping_explore.GleanPingExplore", "modulename": "generator.explores.glean_ping_explore", "qualname": "GleanPingExplore", "type": "class", "doc": "<p>A Glean Ping Table explore.</p>\n", "bases": "generator.explores.ping_explore.PingExplore"}, {"fullname": "generator.explores.glean_ping_explore.GleanPingExplore.type", "modulename": "generator.explores.glean_ping_explore", "qualname": "GleanPingExplore.type", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'glean_ping_explore'"}, {"fullname": "generator.explores.glean_ping_explore.GleanPingExplore.from_views", "modulename": "generator.explores.glean_ping_explore", "qualname": "GleanPingExplore.from_views", "type": "function", "doc": "<p>Generate all possible GleanPingExplores from the views.</p>\n", "signature": "(\n    views: List[generator.views.view.View]\n) -> Iterator[generator.explores.ping_explore.PingExplore]", "funcdef": "def"}, {"fullname": "generator.explores.glean_ping_explore.GleanPingExplore.from_dict", "modulename": "generator.explores.glean_ping_explore", "qualname": "GleanPingExplore.from_dict", "type": "function", "doc": "<p>Get an instance of this explore from a name and dictionary definition.</p>\n", "signature": "(\n    name: str,\n    defn: dict,\n    views_path: pathlib.Path\n) -> generator.explores.glean_ping_explore.GleanPingExplore", "funcdef": "def"}, {"fullname": "generator.explores.growth_accounting_explore", "modulename": "generator.explores.growth_accounting_explore", "type": "module", "doc": "<p>Growth Accounting explore type.</p>\n"}, {"fullname": "generator.explores.growth_accounting_explore.GrowthAccountingExplore", "modulename": "generator.explores.growth_accounting_explore", "qualname": "GrowthAccountingExplore", "type": "class", "doc": "<p>A Growth Accounting Explore, from Baseline Clients Last Seen.</p>\n", "bases": "generator.explores.explore.Explore"}, {"fullname": "generator.explores.growth_accounting_explore.GrowthAccountingExplore.type", "modulename": "generator.explores.growth_accounting_explore", "qualname": "GrowthAccountingExplore.type", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'growth_accounting_explore'"}, {"fullname": "generator.explores.growth_accounting_explore.GrowthAccountingExplore.from_views", "modulename": "generator.explores.growth_accounting_explore", "qualname": "GrowthAccountingExplore.from_views", "type": "function", "doc": "<p>If possible, generate a Growth Accounting explore for this namespace.</p>\n\n<p>Growth accounting explores are only created for growth_accounting views.</p>\n", "signature": "(\n    views: List[generator.views.view.View]\n) -> Iterator[generator.explores.growth_accounting_explore.GrowthAccountingExplore]", "funcdef": "def"}, {"fullname": "generator.explores.growth_accounting_explore.GrowthAccountingExplore.from_dict", "modulename": "generator.explores.growth_accounting_explore", "qualname": "GrowthAccountingExplore.from_dict", "type": "function", "doc": "<p>Get an instance of this explore from a dictionary definition.</p>\n", "signature": "(\n    name: str,\n    defn: dict,\n    views_path: pathlib.Path\n) -> generator.explores.growth_accounting_explore.GrowthAccountingExplore", "funcdef": "def"}, {"fullname": "generator.explores.operational_monitoring_explore", "modulename": "generator.explores.operational_monitoring_explore", "type": "module", "doc": "<p>Operational Monitoring Explore type.</p>\n"}, {"fullname": "generator.explores.operational_monitoring_explore.OperationalMonitoringExplore", "modulename": "generator.explores.operational_monitoring_explore", "qualname": "OperationalMonitoringExplore", "type": "class", "doc": "<p>An Operational Monitoring Explore.</p>\n", "bases": "generator.explores.explore.Explore"}, {"fullname": "generator.explores.operational_monitoring_explore.OperationalMonitoringExplore.__init__", "modulename": "generator.explores.operational_monitoring_explore", "qualname": "OperationalMonitoringExplore.__init__", "type": "function", "doc": "<p>Initialize OperationalMonitoringExplore.</p>\n", "signature": "(\n    self,\n    name: str,\n    views: Dict[str, str],\n    views_path: pathlib.Path = None,\n    defn: Dict[str, Any] = None\n)", "funcdef": "def"}, {"fullname": "generator.explores.operational_monitoring_explore.OperationalMonitoringExplore.type", "modulename": "generator.explores.operational_monitoring_explore", "qualname": "OperationalMonitoringExplore.type", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'operational_monitoring_explore'"}, {"fullname": "generator.explores.operational_monitoring_explore.OperationalMonitoringExplore.from_views", "modulename": "generator.explores.operational_monitoring_explore", "qualname": "OperationalMonitoringExplore.from_views", "type": "function", "doc": "<p>Generate an Operational Monitoring explore for this namespace.</p>\n", "signature": "(\n    views: List[generator.views.view.View]\n) -> Iterator[generator.explores.explore.Explore]", "funcdef": "def"}, {"fullname": "generator.explores.operational_monitoring_explore.OperationalMonitoringExplore.from_dict", "modulename": "generator.explores.operational_monitoring_explore", "qualname": "OperationalMonitoringExplore.from_dict", "type": "function", "doc": "<p>Get an instance of this explore from a dictionary definition.</p>\n", "signature": "(\n    name: str,\n    defn: dict,\n    views_path: pathlib.Path\n) -> generator.explores.operational_monitoring_explore.OperationalMonitoringExplore", "funcdef": "def"}, {"fullname": "generator.explores.ping_explore", "modulename": "generator.explores.ping_explore", "type": "module", "doc": "<p>Ping explore type.</p>\n"}, {"fullname": "generator.explores.ping_explore.PingExplore", "modulename": "generator.explores.ping_explore", "qualname": "PingExplore", "type": "class", "doc": "<p>A Ping Table explore.</p>\n", "bases": "generator.explores.explore.Explore"}, {"fullname": "generator.explores.ping_explore.PingExplore.type", "modulename": "generator.explores.ping_explore", "qualname": "PingExplore.type", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'ping_explore'"}, {"fullname": "generator.explores.ping_explore.PingExplore.from_views", "modulename": "generator.explores.ping_explore", "qualname": "PingExplore.from_views", "type": "function", "doc": "<p>Generate all possible PingExplores from the views.</p>\n", "signature": "(\n    views: List[generator.views.view.View]\n) -> Iterator[generator.explores.ping_explore.PingExplore]", "funcdef": "def"}, {"fullname": "generator.explores.ping_explore.PingExplore.from_dict", "modulename": "generator.explores.ping_explore", "qualname": "PingExplore.from_dict", "type": "function", "doc": "<p>Get an instance of this explore from a name and dictionary definition.</p>\n", "signature": "(\n    name: str,\n    defn: dict,\n    views_path: pathlib.Path\n) -> generator.explores.ping_explore.PingExplore", "funcdef": "def"}, {"fullname": "generator.lkml_update", "modulename": "generator.lkml_update", "type": "module", "doc": "<p>An updated lkml parser to handle explore queries.</p>\n"}, {"fullname": "generator.lkml_update.dump", "modulename": "generator.lkml_update", "qualname": "dump", "type": "function", "doc": "<p>Dump an object as LookML.</p>\n", "signature": "(obj: dict) -> str", "funcdef": "def"}, {"fullname": "generator.lkml_update.UpdatedDictParser", "modulename": "generator.lkml_update", "qualname": "UpdatedDictParser", "type": "class", "doc": "<p>An updated DictParser that properly handles queries.</p>\n", "bases": "lkml.simple.DictParser"}, {"fullname": "generator.lkml_update.UpdatedDictParser.parse_any", "modulename": "generator.lkml_update", "qualname": "UpdatedDictParser.parse_any", "type": "function", "doc": "<p>Dynamically serializes a Python object based on its type.</p>\n\n<p>Args:\n    key: A LookML field type (e.g. \"suggestions\" or \"hidden\")\n    value: A string, tuple, or list to serialize\nRaises:\n    TypeError: If input value is not of a valid type\nReturns:\n    A generator of serialized string chunks</p>\n", "signature": "(\n    self,\n    key: str,\n    value: Union[str, list, tuple, dict]\n) -> Union[List[Union[lkml.tree.BlockNode, lkml.tree.ListNode, lkml.tree.PairNode]], lkml.tree.BlockNode, lkml.tree.ListNode, lkml.tree.PairNode]", "funcdef": "def"}, {"fullname": "generator.lookml", "modulename": "generator.lookml", "type": "module", "doc": "<p>Generate lookml from namespaces.</p>\n"}, {"fullname": "generator.namespaces", "modulename": "generator.namespaces", "type": "module", "doc": "<p>Generate namespaces.yaml.</p>\n"}, {"fullname": "generator.operational_monitoring_utils", "modulename": "generator.operational_monitoring_utils", "type": "module", "doc": "<p>Utils for operational monitoring.</p>\n"}, {"fullname": "generator.operational_monitoring_utils.get_dimension_defaults", "modulename": "generator.operational_monitoring_utils", "qualname": "get_dimension_defaults", "type": "function", "doc": "<p>Find default values for certain dimensions.</p>\n\n<p>For a given Operational Monitoring dimension, find its default (most common)\nvalue and its top 10 most common to be used as dropdown options.</p>\n", "signature": "(\n    bq_client: google.cloud.bigquery.client.Client,\n    table: str,\n    dimensions: List[str]\n) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "generator.operational_monitoring_utils.get_xaxis_val", "modulename": "generator.operational_monitoring_utils", "qualname": "get_xaxis_val", "type": "function", "doc": "<p>Return whether the x-axis should be build_id or submission_date.</p>\n\n<p>This is based on which one is found in the table provided.</p>\n", "signature": "(bq_client: google.cloud.bigquery.client.Client, table: str) -> str", "funcdef": "def"}, {"fullname": "generator.operational_monitoring_utils.get_projects", "modulename": "generator.operational_monitoring_utils", "qualname": "get_projects", "type": "function", "doc": "<p>Select all operational monitoring projects.</p>\n", "signature": "(\n    bq_client: google.cloud.bigquery.client.Client,\n    project_table: str\n) -> List[Dict[str, Any]]", "funcdef": "def"}, {"fullname": "generator.spoke", "modulename": "generator.spoke", "type": "module", "doc": "<p>Generate directories and models for new namespaces.</p>\n"}, {"fullname": "generator.spoke.MODEL_SETS_BY_INSTANCE", "modulename": "generator.spoke", "qualname": "MODEL_SETS_BY_INSTANCE", "type": "variable", "doc": "<p></p>\n", "annotation": ": Dict[str, List[str]]", "default_value": " = {'https://mozilladev.cloud.looker.com': ['mozilla_confidential'], 'https://mozillastaging.cloud.looker.com': ['mozilla_confidential'], 'https://mozilla.cloud.looker.com': ['mozilla_confidential']}"}, {"fullname": "generator.spoke.ExploreDict", "modulename": "generator.spoke", "qualname": "ExploreDict", "type": "class", "doc": "<p>Represent an explore definition.</p>\n", "bases": "builtins.dict"}, {"fullname": "generator.spoke.NamespaceDict", "modulename": "generator.spoke", "qualname": "NamespaceDict", "type": "class", "doc": "<p>Represent a Namespace definition.</p>\n", "bases": "builtins.dict"}, {"fullname": "generator.spoke.setup_env_with_looker_creds", "modulename": "generator.spoke", "qualname": "setup_env_with_looker_creds", "type": "function", "doc": "<p>Set up env with looker credentials.</p>\n\n<p>Returns TRUE if the config is complete.</p>\n", "signature": "() -> bool", "funcdef": "def"}, {"fullname": "generator.spoke.generate_model", "modulename": "generator.spoke", "qualname": "generate_model", "type": "function", "doc": "<p>Generate a model file for a namespace.</p>\n\n<p>We want these to have a nice label and a unique name.\nWe only import explores and dashboards, as we want those\nto auto-import upon generation.</p>\n\n<p>Views are not imported by default, since they should\nbe added one-by-one if they are included in an explore.</p>\n", "signature": "(\n    spoke_path: pathlib.Path,\n    name: str,\n    namespace_defn: generator.spoke.NamespaceDict,\n    db_connection: str\n) -> pathlib.Path", "funcdef": "def"}, {"fullname": "generator.spoke.configure_model", "modulename": "generator.spoke", "qualname": "configure_model", "type": "function", "doc": "<p>Configure a Looker model by name.</p>\n", "signature": "(\n    sdk: looker_sdk.sdk.api31.methods.Looker31SDK,\n    model_name: str,\n    db_connection: str,\n    spoke_project: str\n)", "funcdef": "def"}, {"fullname": "generator.spoke.generate_directories", "modulename": "generator.spoke", "qualname": "generate_directories", "type": "function", "doc": "<p>Generate directories and model for a namespace, if it doesn't exist.</p>\n", "signature": "(\n    namespaces: Dict[str, generator.spoke.NamespaceDict],\n    base_dir: pathlib.Path,\n    sdk_setup=False\n)", "funcdef": "def"}, {"fullname": "generator.views", "modulename": "generator.views", "type": "module", "doc": "<p>All available Looker views.</p>\n"}, {"fullname": "generator.views.client_counts_view", "modulename": "generator.views.client_counts_view", "type": "module", "doc": "<p>Class to describe a Client Counts View.</p>\n"}, {"fullname": "generator.views.client_counts_view.ClientCountsView", "modulename": "generator.views.client_counts_view", "qualname": "ClientCountsView", "type": "class", "doc": "<p>A view for Client Counting measures.</p>\n", "bases": "generator.views.view.View"}, {"fullname": "generator.views.client_counts_view.ClientCountsView.__init__", "modulename": "generator.views.client_counts_view", "qualname": "ClientCountsView.__init__", "type": "function", "doc": "<p>Get an instance of a ClientCountsView.</p>\n", "signature": "(self, namespace: str, tables: List[Dict[str, str]])", "funcdef": "def"}, {"fullname": "generator.views.client_counts_view.ClientCountsView.type", "modulename": "generator.views.client_counts_view", "qualname": "ClientCountsView.type", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'client_counts_view'"}, {"fullname": "generator.views.client_counts_view.ClientCountsView.default_dimension_groups", "modulename": "generator.views.client_counts_view", "qualname": "ClientCountsView.default_dimension_groups", "type": "variable", "doc": "<p></p>\n", "annotation": ": List[Dict[str, Union[str, List[str]]]]", "default_value": " = [{'name': 'since_first_seen', 'type': 'duration', 'description': 'Amount of time that has passed since the client was first seen.', 'sql_start': 'CAST(${TABLE}.first_seen_date AS TIMESTAMP)', 'sql_end': 'CAST(${TABLE}.submission_date AS TIMESTAMP)', 'intervals': ['day', 'week', 'month', 'year']}]"}, {"fullname": "generator.views.client_counts_view.ClientCountsView.default_dimensions", "modulename": "generator.views.client_counts_view", "qualname": "ClientCountsView.default_dimensions", "type": "variable", "doc": "<p></p>\n", "annotation": ": List[Dict[str, str]]", "default_value": " = [{'name': 'have_completed_period', 'type': 'yesno', 'description': 'Only for use with cohort analysis.Filter on true to remove the tail of incomplete data from cohorts.Indicates whether the cohort for this row have all had a chance to complete this interval.For example, new clients from yesterday have not all had a chance to send a ping for today.', 'sql': \"\\n              DATE_ADD(\\n                {% if client_counts.first_seen_date._is_selected %}\\n                  DATE_ADD(DATE(${client_counts.first_seen_date}), INTERVAL 1 DAY)\\n                {% elsif client_counts.first_seen_week._is_selected %}\\n                  DATE_ADD(DATE(${client_counts.first_seen_week}), INTERVAL 1 WEEK)\\n                {% elsif client_counts.first_seen_month._is_selected %}\\n                  DATE_ADD(PARSE_DATE('%Y-%m', ${client_counts.first_seen_month}), INTERVAL 1 MONTH)\\n                {% elsif client_counts.first_seen_year._is_selected %}\\n                  DATE_ADD(DATE(${client_counts.first_seen_year}, 1, 1), INTERVAL 1 YEAR)\\n                {% endif %}\\n                ,\\n                {% if client_counts.days_since_first_seen._is_selected %}\\n                  INTERVAL ${client_counts.days_since_first_seen} DAY\\n                {% elsif client_counts.weeks_since_first_seen._is_selected %}\\n                  INTERVAL ${client_counts.weeks_since_first_seen} WEEK\\n                {% elsif client_counts.months_since_first_seen._is_selected %}\\n                  INTERVAL ${client_counts.months_since_first_seen} MONTH\\n                {% elsif client_counts.years_since_first_seen._is_selected %}\\n                  INTERVAL ${client_counts.months_since_first_seen} YEAR\\n                {% endif %}\\n              ) < current_date\\n              \"}]"}, {"fullname": "generator.views.client_counts_view.ClientCountsView.default_measures", "modulename": "generator.views.client_counts_view", "qualname": "ClientCountsView.default_measures", "type": "variable", "doc": "<p></p>\n", "annotation": ": List[Dict[str, Union[str, List[Dict[str, str]]]]]", "default_value": " = [{'name': 'client_count', 'type': 'number', 'description': 'The number of clients, determined by whether they sent a baseline ping on the day in question.', 'sql': 'COUNT(DISTINCT client_id)'}]"}, {"fullname": "generator.views.client_counts_view.ClientCountsView.from_db_views", "modulename": "generator.views.client_counts_view", "qualname": "ClientCountsView.from_db_views", "type": "function", "doc": "<p>Get Client Count Views from db views and app variants.</p>\n", "signature": "(\n    klass,\n    namespace: str,\n    is_glean: bool,\n    channels: List[Dict[str, str]],\n    db_views: dict\n) -> Iterator[generator.views.client_counts_view.ClientCountsView]", "funcdef": "def"}, {"fullname": "generator.views.client_counts_view.ClientCountsView.from_dict", "modulename": "generator.views.client_counts_view", "qualname": "ClientCountsView.from_dict", "type": "function", "doc": "<p>Get a view from a name and dict definition.</p>\n", "signature": "(\n    klass,\n    namespace: str,\n    name: str,\n    _dict: generator.views.view.ViewDict\n) -> generator.views.client_counts_view.ClientCountsView", "funcdef": "def"}, {"fullname": "generator.views.client_counts_view.ClientCountsView.to_lookml", "modulename": "generator.views.client_counts_view", "qualname": "ClientCountsView.to_lookml", "type": "function", "doc": "<p>Generate LookML for this view.</p>\n", "signature": "(self, bq_client, v1_name: Union[str, NoneType]) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "generator.views.client_counts_view.ClientCountsView.get_measures", "modulename": "generator.views.client_counts_view", "qualname": "ClientCountsView.get_measures", "type": "function", "doc": "<p>Generate measures for the Growth Accounting Framework.</p>\n", "signature": "(self) -> List[Dict[str, Union[str, List[Dict[str, str]]]]]", "funcdef": "def"}, {"fullname": "generator.views.events_view", "modulename": "generator.views.events_view", "type": "module", "doc": "<p>Class to describe an Events view.</p>\n"}, {"fullname": "generator.views.events_view.EventsView", "modulename": "generator.views.events_view", "qualname": "EventsView", "type": "class", "doc": "<p>A view for querying events data, with one row per-event.</p>\n", "bases": "generator.views.view.View"}, {"fullname": "generator.views.events_view.EventsView.__init__", "modulename": "generator.views.events_view", "qualname": "EventsView.__init__", "type": "function", "doc": "<p>Get an instance of an EventsView.</p>\n", "signature": "(self, namespace: str, name: str, tables: List[Dict[str, str]])", "funcdef": "def"}, {"fullname": "generator.views.events_view.EventsView.type", "modulename": "generator.views.events_view", "qualname": "EventsView.type", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'events_view'"}, {"fullname": "generator.views.events_view.EventsView.default_measures", "modulename": "generator.views.events_view", "qualname": "EventsView.default_measures", "type": "variable", "doc": "<p></p>\n", "annotation": ": List[Dict[str, str]]", "default_value": " = [{'name': 'event_count', 'type': 'count', 'description': 'The number of times the event(s) occurred.'}]"}, {"fullname": "generator.views.events_view.EventsView.from_db_views", "modulename": "generator.views.events_view", "qualname": "EventsView.from_db_views", "type": "function", "doc": "<p>Get Events Views from db views and app variants.</p>\n", "signature": "(\n    klass,\n    namespace: str,\n    is_glean: bool,\n    channels: List[Dict[str, str]],\n    db_views: dict\n) -> Iterator[generator.views.events_view.EventsView]", "funcdef": "def"}, {"fullname": "generator.views.events_view.EventsView.from_dict", "modulename": "generator.views.events_view", "qualname": "EventsView.from_dict", "type": "function", "doc": "<p>Get a view from a name and dict definition.</p>\n", "signature": "(\n    klass,\n    namespace: str,\n    name: str,\n    _dict: generator.views.view.ViewDict\n) -> generator.views.events_view.EventsView", "funcdef": "def"}, {"fullname": "generator.views.events_view.EventsView.to_lookml", "modulename": "generator.views.events_view", "qualname": "EventsView.to_lookml", "type": "function", "doc": "<p>Generate LookML for this view.</p>\n", "signature": "(self, bq_client, v1_name: Union[str, NoneType]) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "generator.views.events_view.EventsView.get_measures", "modulename": "generator.views.events_view", "qualname": "EventsView.get_measures", "type": "function", "doc": "<p>Generate measures for Events Views.</p>\n", "signature": "(self, dimensions) -> List[Dict[str, str]]", "funcdef": "def"}, {"fullname": "generator.views.funnel_analysis_view", "modulename": "generator.views.funnel_analysis_view", "type": "module", "doc": "<p>Class to describe a Funnel Analysis View.</p>\n\n<p>We create a single View file and a single Explore file.</p>\n\n<p>The View file has many Looker views defined within it:\n    funnel_analysis: Based on events_daily, has the <code>events</code> string and user dimensions (e.g. country)\n    event_names: The names of events. Used for suggestions.\n    event_N: For each possible funnel step, a single view. This is used to define what that funnel step is.</p>\n\n<p>The Explore's job is to take this generated file an link all those event_N's to the funnel_analysis.\nWe join them via cross join, because event_N views only have 1 row and 1 column - the match_string\nto use for a regex_match on the <code>events</code> string in funnel_analysis.</p>\n\n<p>For example, say we filter event_1 on <code>event</code>: <code>WHERE event in (\"session-start, \"session-end\")</code>\nThen we join that with funnel_analysis: <code>FROM funnel_analysis CROSS JOIN event_1</code>\nThat lets us find out whether the user completed those funnel steps:\n    <code>SELECT REGEXP_CONTAINS(funnel_analysis.events, event_1.match_string) AS completed_step_1</code></p>\n\n<p>The <code>funnel_analysis</code> view has some nice dimensions to hide these details from the end user,\ne.g. <code>completed_funnel_step_N</code>. We can then count those users across dimensions.</p>\n"}, {"fullname": "generator.views.funnel_analysis_view.DEFAULT_NUM_FUNNEL_STEPS", "modulename": "generator.views.funnel_analysis_view", "qualname": "DEFAULT_NUM_FUNNEL_STEPS", "type": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": " = 4"}, {"fullname": "generator.views.funnel_analysis_view.FunnelAnalysisView", "modulename": "generator.views.funnel_analysis_view", "qualname": "FunnelAnalysisView", "type": "class", "doc": "<p>A view for doing Funnel Analysis.</p>\n", "bases": "generator.views.view.View"}, {"fullname": "generator.views.funnel_analysis_view.FunnelAnalysisView.__init__", "modulename": "generator.views.funnel_analysis_view", "qualname": "FunnelAnalysisView.__init__", "type": "function", "doc": "<p>Get an instance of a FunnelAnalysisView.</p>\n", "signature": "(self, namespace: str, tables: List[Dict[str, str]])", "funcdef": "def"}, {"fullname": "generator.views.funnel_analysis_view.FunnelAnalysisView.type", "modulename": "generator.views.funnel_analysis_view", "qualname": "FunnelAnalysisView.type", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'funnel_analysis_view'"}, {"fullname": "generator.views.funnel_analysis_view.FunnelAnalysisView.from_db_views", "modulename": "generator.views.funnel_analysis_view", "qualname": "FunnelAnalysisView.from_db_views", "type": "function", "doc": "<p>Get Client Count Views from db views and app variants.</p>\n\n<p>We only create a FunnelAnalysisView if we have the two necessary db tables:\n    - events_daily\n    - event_types</p>\n", "signature": "(\n    klass,\n    namespace: str,\n    is_glean: bool,\n    channels: List[Dict[str, str]],\n    db_views: dict,\n    num_funnel_steps: int = 4\n) -> Iterator[generator.views.funnel_analysis_view.FunnelAnalysisView]", "funcdef": "def"}, {"fullname": "generator.views.funnel_analysis_view.FunnelAnalysisView.from_dict", "modulename": "generator.views.funnel_analysis_view", "qualname": "FunnelAnalysisView.from_dict", "type": "function", "doc": "<p>Get a FunnalAnalysisView from a dict representation.</p>\n", "signature": "(\n    klass,\n    namespace: str,\n    name: str,\n    _dict: generator.views.view.ViewDict\n) -> generator.views.funnel_analysis_view.FunnelAnalysisView", "funcdef": "def"}, {"fullname": "generator.views.funnel_analysis_view.FunnelAnalysisView.to_lookml", "modulename": "generator.views.funnel_analysis_view", "qualname": "FunnelAnalysisView.to_lookml", "type": "function", "doc": "<p>Get this view as LookML.</p>\n", "signature": "(self, bq_client, v1_name: Union[str, NoneType]) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "generator.views.funnel_analysis_view.FunnelAnalysisView.n_events", "modulename": "generator.views.funnel_analysis_view", "qualname": "FunnelAnalysisView.n_events", "type": "function", "doc": "<p>Get the number of events allowed in this funnel.</p>\n", "signature": "(self) -> int", "funcdef": "def"}, {"fullname": "generator.views.glean_ping_view", "modulename": "generator.views.glean_ping_view", "type": "module", "doc": "<p>Class to describe a Glean Ping View.</p>\n"}, {"fullname": "generator.views.glean_ping_view.GleanPingView", "modulename": "generator.views.glean_ping_view", "qualname": "GleanPingView", "type": "class", "doc": "<p>A view on a ping table for an application using the Glean SDK.</p>\n", "bases": "generator.views.ping_view.PingView"}, {"fullname": "generator.views.glean_ping_view.GleanPingView.type", "modulename": "generator.views.glean_ping_view", "qualname": "GleanPingView.type", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'glean_ping_view'"}, {"fullname": "generator.views.glean_ping_view.GleanPingView.allow_glean", "modulename": "generator.views.glean_ping_view", "qualname": "GleanPingView.allow_glean", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": " = True"}, {"fullname": "generator.views.glean_ping_view.GleanPingView.from_db_views", "modulename": "generator.views.glean_ping_view", "qualname": "GleanPingView.from_db_views", "type": "function", "doc": "<p>Generate GleanPingViews from db views.</p>\n", "signature": "(klass, *args, **kwargs)", "funcdef": "def"}, {"fullname": "generator.views.glean_ping_view.GleanPingView.to_lookml", "modulename": "generator.views.glean_ping_view", "qualname": "GleanPingView.to_lookml", "type": "function", "doc": "<p>Generate LookML for this view.</p>\n\n<p>The Glean views include a labeled metrics, which need to be joined\nagainst the view in the explore.</p>\n", "signature": "(self, bq_client, v1_name: Union[str, NoneType]) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "generator.views.glean_ping_view.GleanPingView.get_dimensions", "modulename": "generator.views.glean_ping_view", "qualname": "GleanPingView.get_dimensions", "type": "function", "doc": "<p>Get the set of dimensions for this view.</p>\n", "signature": "(\n    self,\n    bq_client,\n    table,\n    v1_name: Union[str, NoneType]\n) -> List[Dict[str, Any]]", "funcdef": "def"}, {"fullname": "generator.views.glean_ping_view.GleanPingView.get_measures", "modulename": "generator.views.glean_ping_view", "qualname": "GleanPingView.get_measures", "type": "function", "doc": "<p>Generate measures from a list of dimensions.</p>\n\n<p>When no dimension-specific measures are found, return a single \"count\" measure.</p>\n\n<p>Raise ClickException if dimensions result in duplicate measures.</p>\n", "signature": "(\n    self,\n    dimensions: List[dict],\n    table: str,\n    v1_name: Union[str, NoneType]\n) -> List[Dict[str, Union[str, List[Dict[str, str]]]]]", "funcdef": "def"}, {"fullname": "generator.views.growth_accounting_view", "modulename": "generator.views.growth_accounting_view", "type": "module", "doc": "<p>Class to describe a Growth Accounting View.</p>\n"}, {"fullname": "generator.views.growth_accounting_view.GrowthAccountingView", "modulename": "generator.views.growth_accounting_view", "qualname": "GrowthAccountingView", "type": "class", "doc": "<p>A view for growth accounting measures.</p>\n", "bases": "generator.views.view.View"}, {"fullname": "generator.views.growth_accounting_view.GrowthAccountingView.__init__", "modulename": "generator.views.growth_accounting_view", "qualname": "GrowthAccountingView.__init__", "type": "function", "doc": "<p>Get an instance of a GrowthAccountingView.</p>\n", "signature": "(self, namespace: str, tables: List[Dict[str, str]])", "funcdef": "def"}, {"fullname": "generator.views.growth_accounting_view.GrowthAccountingView.type", "modulename": "generator.views.growth_accounting_view", "qualname": "GrowthAccountingView.type", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'growth_accounting_view'"}, {"fullname": "generator.views.growth_accounting_view.GrowthAccountingView.other_dimensions", "modulename": "generator.views.growth_accounting_view", "qualname": "GrowthAccountingView.other_dimensions", "type": "variable", "doc": "<p></p>\n", "annotation": ": List[Dict[str, str]]", "default_value": " = [{'name': 'first', 'sql': '{TABLE}.first', 'type': 'yesno', 'hidden': 'yes'}]"}, {"fullname": "generator.views.growth_accounting_view.GrowthAccountingView.default_dimensions", "modulename": "generator.views.growth_accounting_view", "qualname": "GrowthAccountingView.default_dimensions", "type": "variable", "doc": "<p></p>\n", "annotation": ": List[Dict[str, str]]", "default_value": " = [{'name': 'active_this_week', 'sql': 'mozfun.bits28.active_in_range(days_seen_bits, -6, 7)', 'type': 'yesno', 'hidden': 'yes'}, {'name': 'active_last_week', 'sql': 'mozfun.bits28.active_in_range(days_seen_bits, -13, 7)', 'type': 'yesno', 'hidden': 'yes'}, {'name': 'new_this_week', 'sql': 'DATE_DIFF(${submission_date}, first_run_date, DAY) BETWEEN 0 AND 6', 'type': 'yesno', 'hidden': 'yes'}, {'name': 'new_last_week', 'sql': 'DATE_DIFF(${submission_date}, first_run_date, DAY) BETWEEN 7 AND 13', 'type': 'yesno', 'hidden': 'yes'}, {'name': 'client_id_day', 'sql': 'CONCAT(CAST(${TABLE}.submission_date AS STRING), client_id)', 'type': 'string', 'hidden': 'yes', 'primary_key': 'yes'}]"}, {"fullname": "generator.views.growth_accounting_view.GrowthAccountingView.default_measures", "modulename": "generator.views.growth_accounting_view", "qualname": "GrowthAccountingView.default_measures", "type": "variable", "doc": "<p></p>\n", "annotation": ": List[Dict[str, Union[str, List[Dict[str, str]]]]]", "default_value": " = [{'name': 'overall_active_previous', 'type': 'count', 'filters': [{'active_last_week': 'yes'}]}, {'name': 'overall_active_current', 'type': 'count', 'filters': [{'active_this_week': 'yes'}]}, {'name': 'overall_resurrected', 'type': 'count', 'filters': [{'new_last_week': 'no'}, {'new_this_week': 'no'}, {'active_last_week': 'no'}, {'active_this_week': 'yes'}]}, {'name': 'new_users', 'type': 'count', 'filters': [{'new_this_week': 'yes'}, {'active_this_week': 'yes'}]}, {'name': 'established_users_returning', 'type': 'count', 'filters': [{'new_last_week': 'no'}, {'new_this_week': 'no'}, {'active_last_week': 'yes'}, {'active_this_week': 'yes'}]}, {'name': 'new_users_returning', 'type': 'count', 'filters': [{'new_last_week': 'yes'}, {'active_last_week': 'yes'}, {'active_this_week': 'yes'}]}, {'name': 'new_users_churned_count', 'type': 'count', 'filters': [{'new_last_week': 'yes'}, {'active_last_week': 'yes'}, {'active_this_week': 'no'}]}, {'name': 'established_users_churned_count', 'type': 'count', 'filters': [{'new_last_week': 'no'}, {'new_this_week': 'no'}, {'active_last_week': 'yes'}, {'active_this_week': 'no'}]}, {'name': 'new_users_churned', 'type': 'number', 'sql': '-1 * ${new_users_churned_count}'}, {'name': 'established_users_churned', 'type': 'number', 'sql': '-1 * ${established_users_churned_count}'}, {'name': 'overall_churned', 'type': 'number', 'sql': '${new_users_churned} + ${established_users_churned}'}, {'name': 'overall_retention_rate', 'type': 'number', 'sql': 'SAFE_DIVIDE((${established_users_returning} + ${new_users_returning}),${overall_active_previous})'}, {'name': 'established_user_retention_rate', 'type': 'number', 'sql': 'SAFE_DIVIDE(${established_users_returning},(${established_users_returning} + ${established_users_churned_count}))'}, {'name': 'new_user_retention_rate', 'type': 'number', 'sql': 'SAFE_DIVIDE(${new_users_returning},(${new_users_returning} + ${new_users_churned_count}))'}, {'name': 'overall_churn_rate', 'type': 'number', 'sql': 'SAFE_DIVIDE((${established_users_churned_count} + ${new_users_churned_count}),${overall_active_previous})'}, {'name': 'fraction_of_active_resurrected', 'type': 'number', 'sql': 'SAFE_DIVIDE(${overall_resurrected}, ${overall_active_current})'}, {'name': 'fraction_of_active_new', 'type': 'number', 'sql': 'SAFE_DIVIDE(${new_users}, ${overall_active_current})'}, {'name': 'fraction_of_active_established_returning', 'type': 'number', 'sql': 'SAFE_DIVIDE(${established_users_returning},${overall_active_current})'}, {'name': 'fraction_of_active_new_returning', 'type': 'number', 'sql': 'SAFE_DIVIDE(${new_users_returning}, ${overall_active_current})'}, {'name': 'quick_ratio', 'type': 'number', 'sql': 'SAFE_DIVIDE(${new_users} + ${overall_resurrected},${established_users_churned_count} + ${new_users_churned_count})'}]"}, {"fullname": "generator.views.growth_accounting_view.GrowthAccountingView.from_db_views", "modulename": "generator.views.growth_accounting_view", "qualname": "GrowthAccountingView.from_db_views", "type": "function", "doc": "<p>Get Growth Accounting Views from db views and app variants.</p>\n", "signature": "(\n    klass,\n    namespace: str,\n    is_glean: bool,\n    channels: List[Dict[str, str]],\n    db_views: dict\n) -> Iterator[generator.views.growth_accounting_view.GrowthAccountingView]", "funcdef": "def"}, {"fullname": "generator.views.growth_accounting_view.GrowthAccountingView.from_dict", "modulename": "generator.views.growth_accounting_view", "qualname": "GrowthAccountingView.from_dict", "type": "function", "doc": "<p>Get a view from a name and dict definition.</p>\n", "signature": "(\n    klass,\n    namespace: str,\n    name: str,\n    _dict: generator.views.view.ViewDict\n) -> generator.views.growth_accounting_view.GrowthAccountingView", "funcdef": "def"}, {"fullname": "generator.views.growth_accounting_view.GrowthAccountingView.to_lookml", "modulename": "generator.views.growth_accounting_view", "qualname": "GrowthAccountingView.to_lookml", "type": "function", "doc": "<p>Generate LookML for this view.</p>\n", "signature": "(self, bq_client, v1_name: Union[str, NoneType]) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "generator.views.growth_accounting_view.GrowthAccountingView.get_measures", "modulename": "generator.views.growth_accounting_view", "qualname": "GrowthAccountingView.get_measures", "type": "function", "doc": "<p>Generate measures for the Growth Accounting Framework.</p>\n", "signature": "(self) -> List[Dict[str, Union[str, List[Dict[str, str]]]]]", "funcdef": "def"}, {"fullname": "generator.views.lookml_utils", "modulename": "generator.views.lookml_utils", "type": "module", "doc": "<p>Utils for generating lookml.</p>\n"}, {"fullname": "generator.views.lookml_utils.escape_filter_expr", "modulename": "generator.views.lookml_utils", "qualname": "escape_filter_expr", "type": "function", "doc": "<p>Escape filter expression for special Looker chars.</p>\n", "signature": "(expr: str) -> str", "funcdef": "def"}, {"fullname": "generator.views.lookml_utils.render_template", "modulename": "generator.views.lookml_utils", "qualname": "render_template", "type": "function", "doc": "<p>Render a given template using Jinja.</p>\n", "signature": "(filename, template_folder, **kwargs) -> str", "funcdef": "def"}, {"fullname": "generator.views.lookml_utils.get_distinct_vals", "modulename": "generator.views.lookml_utils", "qualname": "get_distinct_vals", "type": "function", "doc": "<p>Given a table and column name, return all distinct values for that column.</p>\n", "signature": "(\n    bq_client: google.cloud.bigquery.client.Client,\n    table: str,\n    column: str\n)", "funcdef": "def"}, {"fullname": "generator.views.lookml_utils.slug_to_title", "modulename": "generator.views.lookml_utils", "qualname": "slug_to_title", "type": "function", "doc": "<p>Convert a slug to title case.</p>\n", "signature": "(slug)", "funcdef": "def"}, {"fullname": "generator.views.operational_monitoring_histogram_view", "modulename": "generator.views.operational_monitoring_histogram_view", "type": "module", "doc": "<p>Class to describe an Operational Monitoring Histogram View.</p>\n"}, {"fullname": "generator.views.operational_monitoring_histogram_view.OperationalMonitoringHistogramView", "modulename": "generator.views.operational_monitoring_histogram_view", "qualname": "OperationalMonitoringHistogramView", "type": "class", "doc": "<p>A view on a scalar operational monitoring table.</p>\n", "bases": "generator.views.operational_monitoring_view.OperationalMonitoringView"}, {"fullname": "generator.views.operational_monitoring_histogram_view.OperationalMonitoringHistogramView.type", "modulename": "generator.views.operational_monitoring_histogram_view", "qualname": "OperationalMonitoringHistogramView.type", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'operational_monitoring_histogram_view'"}, {"fullname": "generator.views.operational_monitoring_histogram_view.OperationalMonitoringHistogramView.to_lookml", "modulename": "generator.views.operational_monitoring_histogram_view", "qualname": "OperationalMonitoringHistogramView.to_lookml", "type": "function", "doc": "<p>Get this view as LookML.</p>\n", "signature": "(self, bq_client, v1_name: Union[str, NoneType]) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "generator.views.operational_monitoring_scalar_view", "modulename": "generator.views.operational_monitoring_scalar_view", "type": "module", "doc": "<p>Class to describe an Operational Monitoring Scalar View.</p>\n"}, {"fullname": "generator.views.operational_monitoring_scalar_view.OperationalMonitoringScalarView", "modulename": "generator.views.operational_monitoring_scalar_view", "qualname": "OperationalMonitoringScalarView", "type": "class", "doc": "<p>A view on a scalar operational monitoring table.</p>\n", "bases": "generator.views.operational_monitoring_view.OperationalMonitoringView"}, {"fullname": "generator.views.operational_monitoring_scalar_view.OperationalMonitoringScalarView.type", "modulename": "generator.views.operational_monitoring_scalar_view", "qualname": "OperationalMonitoringScalarView.type", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'operational_monitoring_scalar_view'"}, {"fullname": "generator.views.operational_monitoring_scalar_view.OperationalMonitoringScalarView.to_lookml", "modulename": "generator.views.operational_monitoring_scalar_view", "qualname": "OperationalMonitoringScalarView.to_lookml", "type": "function", "doc": "<p>Get this view as LookML.</p>\n", "signature": "(self, bq_client, v1_name: Union[str, NoneType]) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "generator.views.operational_monitoring_view", "modulename": "generator.views.operational_monitoring_view", "type": "module", "doc": "<p>Class to describe an Operational Monitoring View.</p>\n"}, {"fullname": "generator.views.operational_monitoring_view.OperationalMonitoringView", "modulename": "generator.views.operational_monitoring_view", "qualname": "OperationalMonitoringView", "type": "class", "doc": "<p>A view on a operational monitoring table.</p>\n", "bases": "generator.views.ping_view.PingView"}, {"fullname": "generator.views.operational_monitoring_view.OperationalMonitoringView.__init__", "modulename": "generator.views.operational_monitoring_view", "qualname": "OperationalMonitoringView.__init__", "type": "function", "doc": "<p>Create instance of a OperationalMonitoringView.</p>\n", "signature": "(self, namespace: str, name: str, tables: List[Dict[str, Any]])", "funcdef": "def"}, {"fullname": "generator.views.operational_monitoring_view.OperationalMonitoringView.type", "modulename": "generator.views.operational_monitoring_view", "qualname": "OperationalMonitoringView.type", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'operational_monitoring_view'"}, {"fullname": "generator.views.operational_monitoring_view.OperationalMonitoringView.percentile_ci_labels", "modulename": "generator.views.operational_monitoring_view", "qualname": "OperationalMonitoringView.percentile_ci_labels", "type": "variable", "doc": "<p></p>\n", "default_value": " = ['percentile', 'low', 'high']"}, {"fullname": "generator.views.operational_monitoring_view.OperationalMonitoringView.from_dict", "modulename": "generator.views.operational_monitoring_view", "qualname": "OperationalMonitoringView.from_dict", "type": "function", "doc": "<p>Get a OperationalMonitoringView from a dict representation.</p>\n", "signature": "(\n    klass,\n    namespace: str,\n    name: str,\n    _dict: generator.views.view.ViewDict\n) -> generator.views.operational_monitoring_view.OperationalMonitoringView", "funcdef": "def"}, {"fullname": "generator.views.operational_monitoring_view.OperationalMonitoringView.to_lookml", "modulename": "generator.views.operational_monitoring_view", "qualname": "OperationalMonitoringView.to_lookml", "type": "function", "doc": "<p>Get this view as LookML.</p>\n", "signature": "(self, bq_client, v1_name: Union[str, NoneType]) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "generator.views.ping_view", "modulename": "generator.views.ping_view", "type": "module", "doc": "<p>Class to describe a Ping View.</p>\n"}, {"fullname": "generator.views.ping_view.PingView", "modulename": "generator.views.ping_view", "qualname": "PingView", "type": "class", "doc": "<p>A view on a ping table.</p>\n", "bases": "generator.views.view.View"}, {"fullname": "generator.views.ping_view.PingView.__init__", "modulename": "generator.views.ping_view", "qualname": "PingView.__init__", "type": "function", "doc": "<p>Create instance of a PingView.</p>\n", "signature": "(self, namespace: str, name: str, tables: List[Dict[str, Any]])", "funcdef": "def"}, {"fullname": "generator.views.ping_view.PingView.type", "modulename": "generator.views.ping_view", "qualname": "PingView.type", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'ping_view'"}, {"fullname": "generator.views.ping_view.PingView.allow_glean", "modulename": "generator.views.ping_view", "qualname": "PingView.allow_glean", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": " = False"}, {"fullname": "generator.views.ping_view.PingView.from_db_views", "modulename": "generator.views.ping_view", "qualname": "PingView.from_db_views", "type": "function", "doc": "<p>Get Looker views for a namespace.</p>\n", "signature": "(\n    klass,\n    namespace: str,\n    is_glean: bool,\n    channels: List[Dict[str, str]],\n    db_views: dict\n) -> Iterator[generator.views.ping_view.PingView]", "funcdef": "def"}, {"fullname": "generator.views.ping_view.PingView.from_dict", "modulename": "generator.views.ping_view", "qualname": "PingView.from_dict", "type": "function", "doc": "<p>Get a view from a name and dict definition.</p>\n", "signature": "(\n    klass,\n    namespace: str,\n    name: str,\n    _dict: generator.views.view.ViewDict\n) -> generator.views.ping_view.PingView", "funcdef": "def"}, {"fullname": "generator.views.ping_view.PingView.to_lookml", "modulename": "generator.views.ping_view", "qualname": "PingView.to_lookml", "type": "function", "doc": "<p>Generate LookML for this view.</p>\n", "signature": "(self, bq_client, v1_name: Union[str, NoneType]) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "generator.views.ping_view.PingView.get_dimensions", "modulename": "generator.views.ping_view", "qualname": "PingView.get_dimensions", "type": "function", "doc": "<p>Get the set of dimensions for this view.</p>\n", "signature": "(\n    self,\n    bq_client,\n    table,\n    v1_name: Union[str, NoneType]\n) -> List[Dict[str, Any]]", "funcdef": "def"}, {"fullname": "generator.views.ping_view.PingView.get_measures", "modulename": "generator.views.ping_view", "qualname": "PingView.get_measures", "type": "function", "doc": "<p>Generate measures from a list of dimensions.</p>\n\n<p>When no dimension-specific measures are found, return a single \"count\" measure.</p>\n\n<p>Raise ClickException if dimensions result in duplicate measures.</p>\n", "signature": "(\n    self,\n    dimensions: List[dict],\n    table: str,\n    v1_name: Union[str, NoneType]\n) -> List[Dict[str, Union[str, List[Dict[str, str]]]]]", "funcdef": "def"}, {"fullname": "generator.views.table_view", "modulename": "generator.views.table_view", "type": "module", "doc": "<p>Class to describe a Table View.</p>\n"}, {"fullname": "generator.views.table_view.TableView", "modulename": "generator.views.table_view", "qualname": "TableView", "type": "class", "doc": "<p>A view on any table.</p>\n", "bases": "generator.views.view.View"}, {"fullname": "generator.views.table_view.TableView.__init__", "modulename": "generator.views.table_view", "qualname": "TableView.__init__", "type": "function", "doc": "<p>Create instance of a TableView.</p>\n", "signature": "(self, namespace: str, name: str, tables: List[Dict[str, str]])", "funcdef": "def"}, {"fullname": "generator.views.table_view.TableView.type", "modulename": "generator.views.table_view", "qualname": "TableView.type", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'table_view'"}, {"fullname": "generator.views.table_view.TableView.from_db_views", "modulename": "generator.views.table_view", "qualname": "TableView.from_db_views", "type": "function", "doc": "<p>Get Looker views for a namespace.</p>\n", "signature": "(\n    klass,\n    namespace: str,\n    is_glean: bool,\n    channels: List[Dict[str, str]],\n    db_views: dict\n) -> Iterator[generator.views.table_view.TableView]", "funcdef": "def"}, {"fullname": "generator.views.table_view.TableView.from_dict", "modulename": "generator.views.table_view", "qualname": "TableView.from_dict", "type": "function", "doc": "<p>Get a view from a name and dict definition.</p>\n", "signature": "(\n    klass,\n    namespace: str,\n    name: str,\n    _dict: generator.views.view.ViewDict\n) -> generator.views.table_view.TableView", "funcdef": "def"}, {"fullname": "generator.views.table_view.TableView.to_lookml", "modulename": "generator.views.table_view", "qualname": "TableView.to_lookml", "type": "function", "doc": "<p>Generate LookML for this view.</p>\n", "signature": "(self, bq_client, v1_name: Union[str, NoneType]) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "generator.views.view", "modulename": "generator.views.view", "type": "module", "doc": "<p>Generic class to describe Looker views.</p>\n"}, {"fullname": "generator.views.view.OMIT_VIEWS", "modulename": "generator.views.view", "qualname": "OMIT_VIEWS", "type": "variable", "doc": "<p></p>\n", "annotation": ": Set[str]", "default_value": " = set()"}, {"fullname": "generator.views.view.ViewDict", "modulename": "generator.views.view", "qualname": "ViewDict", "type": "class", "doc": "<p>Represent a view definition.</p>\n", "bases": "builtins.dict"}, {"fullname": "generator.views.view.View", "modulename": "generator.views.view", "qualname": "View", "type": "class", "doc": "<p>A generic Looker View.</p>\n"}, {"fullname": "generator.views.view.View.__init__", "modulename": "generator.views.view", "qualname": "View.__init__", "type": "function", "doc": "<p>Create an instance of a view.</p>\n", "signature": "(\n    self,\n    namespace: str,\n    name: str,\n    view_type: str,\n    tables: List[Dict[str, Any]],\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "generator.views.view.View.from_db_views", "modulename": "generator.views.view", "qualname": "View.from_db_views", "type": "function", "doc": "<p>Get Looker views from app.</p>\n", "signature": "(\n    klass,\n    namespace: str,\n    is_glean: bool,\n    channels: List[Dict[str, str]],\n    db_views: dict\n) -> Iterator[generator.views.view.View]", "funcdef": "def"}, {"fullname": "generator.views.view.View.from_dict", "modulename": "generator.views.view", "qualname": "View.from_dict", "type": "function", "doc": "<p>Get a view from a name and dict definition.</p>\n", "signature": "(\n    klass,\n    namespace: str,\n    name: str,\n    _dict: generator.views.view.ViewDict\n) -> generator.views.view.View", "funcdef": "def"}, {"fullname": "generator.views.view.View.get_type", "modulename": "generator.views.view", "qualname": "View.get_type", "type": "function", "doc": "<p>Get the type of this view.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "generator.views.view.View.as_dict", "modulename": "generator.views.view", "qualname": "View.as_dict", "type": "function", "doc": "<p>Get this view as a dictionary.</p>\n", "signature": "(self) -> dict", "funcdef": "def"}, {"fullname": "generator.views.view.View.get_dimensions", "modulename": "generator.views.view", "qualname": "View.get_dimensions", "type": "function", "doc": "<p>Get the set of dimensions for this view.</p>\n", "signature": "(\n    self,\n    bq_client,\n    table,\n    v1_name: Union[str, NoneType]\n) -> List[Dict[str, Any]]", "funcdef": "def"}, {"fullname": "generator.views.view.View.to_lookml", "modulename": "generator.views.view", "qualname": "View.to_lookml", "type": "function", "doc": "<p>Generate Lookml for this view.</p>\n\n<p>View instances can generate more than one Looker view,\nfor e.g. nested fields and joins, so this returns\na list.</p>\n", "signature": "(self, bq_client, v1_name: Union[str, NoneType]) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "generator.views.view.View.get_client_id", "modulename": "generator.views.view", "qualname": "View.get_client_id", "type": "function", "doc": "<p>Return the first field that looks like a client identifier.</p>\n", "signature": "(self, dimensions: List[dict], table: str) -> Union[str, NoneType]", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();